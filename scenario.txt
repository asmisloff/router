- Оптимизировать представление узлов и ребер
    - Вместо Complex хранить примитывные float-ы, существующий интерфейс поддержать через свойства

- В конструктор мгновенной схемы передается
    - виртуальная СХЕМА
    - мгновенная схема (начальное состояние)
    - функция getAlternateNetworkById
    - функция, возвращающая экземпляр трассировщика
    - функция, возвращающая экземпляр решателя САУ
    - индексатор узлов графа
    - модель внешней сети (опционально)
    - график движения (опционально)
- В конструкторе мгн. схемы
    - по виртуальной схеме строятся блоки и сохраняются в список
    - тяговая сеть, хранящаяся в виртуальной схеме, преобразуется в форму Map<Int, NavigableSet<BranchNetworkChainLink>>
        - ключ - индекс ветви
        - значение - упорядоченное множество секций ТС данной ветви, отношение больше-меньше-равно устанавливается полем xRight
    - создается и сохраняется граф схемы; в него добавляются подграфы, соответствующие статическим блокам
    - создается и сохраняется трассировщик
        - в конструктор:
            - граф схемы
            - тяговая сеть
        - создаются разделы (AcNetworkPartition) тяговой сети
    - инициализируется трассировщик
        - если графика движения нет, вызывается метод init(payloads: NavigableSet<ISchemaPayload>)
            - он вычисляет количество ячеек для каждого раздела
            - затем создает ячейки и добавляет новые узлы и ребра в граф схемы
        - если график движения есть, вызывается метод init(sch: MotionSchedule, payloads: NavigableSet<ISchemaPayload>)
            - он вычисляет количество ячеек для каждого раздела в следующем порядке:
                - сначала по нагрузкам из мгновенной схемы,
                - затем прохдит по графику движения, на каждом шаге собирает с него нагрузки и обновляет количество ячеек в разделах
            - затем создает ячейки и добавляет новые узлы и ребра в граф схемы
    - создается и сохраняется решатель САУ
    - далее, если графика движения нет, вызывается метод InstantCircuitAsSolver.solve(freq: Double): InstantCircuitAcDto.
      Вернувшееся значение есть конечный результат.
    - Если график есть.
        - Вызывается метод solveOnSchedule(freq: Double): ICompactSolutionChunk.
          Он проходит по графику в расчетных границах, собирает с него нагрузки и переносит на схему методом
          InstantCircuitAcRouter.arrangePayloads(payloads: NavigableSet<ISchemaPayload>). Порядок работы attachPayloads следующий.
            - Удалить нагрузки, оставшиеся с предыдущего шага.
                - Пройти по всем разделам и удалить из графа все ребра, хранящиеся в коллекции lastAttachedPayloadEdges, затем очистить саму коллекцию.
            - Разместить новые нагрузки
                - растянуть ячейки так, чтобы нагрузки расположились в узлах
                - добавить в граф ребра, соответствующие нагрузкам
            - Подготовить решатель САУ:
                - восстановить исходную матрицу системы
                - обнулить вектор свободных членов
                - повторно перечитать граф
            - Рассчитать схему, результаты сохранить в SolutionChunk
            - Повторять описанные действия через каждые avgPeriod минут, пока не встетится правая граница графика движения.

- Для отладки изучить варианты визуализации
    - https://charts-kt.io -- ?